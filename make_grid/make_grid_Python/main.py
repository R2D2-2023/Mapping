import cv2
import numpy as np
from win32api import GetSystemMetrics

##
# @file main.py
# @brief functions for creating a grid over a given image, for drawing on the grid 

##!
# @class MouseData
# @brief Represents mouse-related data and properties.
#
# This class encapsulates various attributes and data related to mouse behavior
# and processing. It provides properties for managing the mouse matrix, cell size,
# images, counters, route information, and other variables.
#
class MouseData:
    ##!
    # @brief Initializes a new instance of the MouseData class.
    #
    # This constructor initializes the MouseData object with default values for
    # the matrix, cell size, images, counters, route, and other variables.
    #
    def __init__(self):
        ## The mouse matrix.
        self.matrix = None
        ## The size of each cell in the matrix.
        self.cell_size = 0
        ## The current image.
        self.img = None
        ## The original image.
        self.orig_img = None
        ## The counter value.
        self.counter = 0
        ## The checkpoint counter value.
        self.checkpoint_counter = -5
        ## The mouse's route information.
        self.route = []
        ## The meetPunten list.
        self.meetPunten = []
        ## The hoeken list.
        self.hoeken = []
        ## the delete list.
        self.delete = []
        ## The X-coordinate of the robot.
        self.robotX = 10
        ## The Y-coordinate of the robot.
        self.robotY = 10
        ## The mode value.
        self.mode = 0

##!
# @class GridData
# @brief Represents a grid data object.
#
# The GridData class manages grid-related data, including the beginning and ending coordinates.
#
class GridData:
    ##!
    # @brief Constructs a new GridData object.
    #
    # The constructor initializes the beginning and ending coordinates of the grid.
    #
    def __init__(self):
        ## The x-coordinate of the beginning of the grid.
        self.beginX = 0
        ## The y-coordinate of the beginning of the grid.
        self.beginY = 0
        ## the grid image
        self.grid_image = None

##!
# @class StoreData
# @brief Class for storing data.
#
# This class provides a mechanism for storing data using two different data types:
# - GridData: Represents grid-based data.
# - MouseData: Represents mouse-related data.
#
class StoreData:
    def __init__(self):
        self.gData = GridData()
        self.MData = MouseData()

##!
# @brief Updates the grid image based on the provided matrix data.
#
# This function takes a matrix and data object as input and updates the grid image.
# The grid image is generated by drawing rectangles on a copy of the original image
# using colors based on the values in the matrix.
#
# @param matrix The matrix containing the values.
# @param data The data object containing additional information.
#
# @return None.
#
def updateGridImage(matrix, data):
    grid_color = (0, 0, 255)
    grid_color_green = (0, 255, 0)
    grid_color_checkpoint = (255, 0, 255)
    grid_color_corner = (255, 0, 0)
    grid_img = data.gData.grid_image.copy()
    cell_size = data.MData.cell_size

    # Convert matrix to NumPy array for faster computations
    matrix = np.array(matrix)

    # Draw initial grid cells
    for coord in data.MData.route:
        x = data.gData.beginX + coord[1] * cell_size
        y = data.gData.beginY + coord[0] * cell_size
        cv2.rectangle(grid_img, (x, y), (x + cell_size, y + cell_size), grid_color_green, -1)

    for coord in data.MData.meetPunten:
        x = data.gData.beginX + coord[1] * cell_size
        y = data.gData.beginY + coord[0] * cell_size
        cv2.rectangle(grid_img, (x, y), (x + cell_size, y + cell_size), grid_color_checkpoint, -1)

    for coord in data.MData.hoeken:
        x = data.gData.beginX + coord[1] * cell_size
        y = data.gData.beginY + coord[0] * cell_size
        cv2.rectangle(grid_img, (x, y), (x + cell_size, y + cell_size), grid_color_corner, -1)

    # Remove deleted cells
    delete_coords = np.array(data.MData.delete)
    for coord in delete_coords:
        x = data.gData.beginX + coord[1] * cell_size
        y = data.gData.beginY + coord[0] * cell_size
        cv2.rectangle(grid_img, (x, y), (x + cell_size, y + cell_size), grid_color, 1)

    # Update the data.MData.delete list with non-deleted coordinates
    data.MData.delete = list(delete_coords)

    cv2.imshow("Grid Image", grid_img)
    

##!
#  Display the initial grid with grid cells.
#
#  @brief This function takes a matrix and displays it as a grid with cells using OpenCV.
#
#  @param matrix: The input matrix representing the grid.
#  @param data: Additional data required for displaying the grid.
#
def showInitialGrid(matrix, data):
    grid_color = (0, 0, 255)
    grid_img = data.MData.orig_img.copy()
    cell_size = data.MData.cell_size

    # Convert matrix to NumPy array for faster computations
    matrix = np.array(matrix)

    # Draw grid cells
    for i in range(matrix.shape[0]):
        y = data.gData.beginY + i * cell_size
        for j in range(matrix.shape[1]):
            x = data.gData.beginX + j * cell_size

            cv2.rectangle(grid_img, (x, y), (x + cell_size, y + cell_size), grid_color, 1)
    data.gData.grid_image = grid_img
    
    # Update the grid image with the initial grid
    updateGridImage(matrix, data)


##!
# @brief Edits an image by resizing and centering it on the screen.
#
# This function reads an image from the specified file, resizes it to fit the screen dimensions while preserving the aspect ratio, and centers it on the screen.
#
# @param filename The path to the image file to be edited.
# @return The edited image.
#
def editImage(filename):
    screen_Width = GetSystemMetrics(0)
    screen_Height = GetSystemMetrics(1)

    img = cv2.imread(filename, cv2.IMREAD_COLOR)
    if img is None:
        print("Could not read the image")

    image_Aspect_Ratio = img.shape[1] / img.shape[0]
    
    max_Width = screen_Width
    max_Height = screen_Height

    scaled_Width = max_Width
    scaled_Height = int(scaled_Width / image_Aspect_Ratio)

    if scaled_Height > max_Height:
        scaled_Height = max_Height
        scaled_Width = int(scaled_Height * image_Aspect_Ratio)

    pos_X = (screen_Width - scaled_Width) // 2
    pos_Y = (screen_Height - scaled_Height) // 2

    cv2.namedWindow("Grid Image")
    cv2.moveWindow("Grid Image", pos_X, pos_Y)
    img = cv2.resize(img, (scaled_Width, scaled_Height))

    return img


##!
# @brief Extracts the ROI from an image.
#
# This function takes an image as input and returns the ROI, start point, and end point of the grid.
#
# @param img The input image.
# @return A tuple containing the ROI image, start point, and end point.
#
def getRoi(img):
    hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # Define the lower and upper bounds of the black color range
    lower = np.array([0, 0, 0])
    upper = np.array([180, 255, 30])

    # Create a mask to filter out non-black pixels
    mask = cv2.inRange(hsv_img, lower, upper)
    
    # Apply the mask to the original image
    mask_img = cv2.bitwise_and(img, img, mask=mask)

    # Find the coordinates of black pixels
    coords = np.where(mask == 255)
    
    # Find the highest, lowest, leftmost, and rightmost points
    highest_point = None
    lowest_point = None
    leftmost_point = None
    rightmost_point = None

    for y, x in zip(coords[0], coords[1]):
        if highest_point is None or y < highest_point[1]:
            highest_point = (x, y)
        if lowest_point is None or y > lowest_point[1]:
            lowest_point = (x, y)
        if leftmost_point is None or x < leftmost_point[0]:
            leftmost_point = (x, y)
        if rightmost_point is None or x > rightmost_point[0]:
            rightmost_point = (x, y)

    start_point = (leftmost_point[0], highest_point[1]) if leftmost_point is not None else (0, 0)
    end_point = (rightmost_point[0], lowest_point[1]) if rightmost_point is not None else (0, 0)
    
    return mask_img, start_point, end_point


##!
# @brief Callback function for handling mouse events.
#
# This function is called when a mouse event occurs.
#
# @param event The type of mouse event (e.g., cv2.EVENT_MOUSEMOVE, cv2.EVENT_MOUSEWHEEL).
# @param x The x-coordinate of the mouse cursor.
# @param y The y-coordinate of the mouse cursor.
# @param flags Additional flags indicating the state of the mouse buttons.
# @param user_data User-defined data passed to the callback function.
#
def onMouse(event, x, y, flags, user_data):
    data = user_data
    cell_size = data.MData.cell_size
    matrix = data.MData.matrix
    matrix_width = len(matrix[0])
    matrix_height = len(matrix)

    j = (x - data.gData.beginX) // cell_size
    i = (y - data.gData.beginY) // cell_size

    if 0 <= i < matrix_height and 0 <= j < matrix_width:
        current_cell = matrix[i][j]  # Get the current value from the matrix

        if event == cv2.EVENT_MOUSEMOVE:
            if data.MData.mode == 0:
                if flags & cv2.EVENT_FLAG_LBUTTON:
                    if current_cell == 0:
                        data.MData.counter += 1
                        current_cell = data.MData.counter
                        matrix[i][j] = current_cell  # Update the value in the matrix
                        updateGridImage(matrix, data)
                        data.MData.route.append((i, j))
                        print(f"{j}/{i}: {data.MData.counter}")
                        print("route:", ",".join(f"{coord[0]}/{coord[1]}" for coord in data.MData.route))
                elif flags & cv2.EVENT_FLAG_RBUTTON:
                    if current_cell != 0:
                        route_it = next((index for index, coord in enumerate(data.MData.route) if coord == (i, j)), None)
                        meetpunten_it = next((index for index, coord in enumerate(data.MData.meetPunten) if coord == (i, j)), None)
                        if route_it is not None or meetpunten_it is not None:
                            if route_it is not None:
                                data.MData.route.pop(route_it)
                            if meetpunten_it is not None:
                                data.MData.meetPunten.pop(meetpunten_it)
                            current_cell = 0
                            matrix[i][j] = current_cell  # Update the value in the matrix
                            updateGridImage(matrix, data)
                            data.MData.delete.append((i, j))
            elif data.MData.mode == 1:
                if flags & cv2.EVENT_FLAG_LBUTTON:
                    if current_cell == 0:
                        current_cell = 9999
                        matrix[i][j] = current_cell  # Update the value in the matrix
                        updateGridImage(matrix, data)
                        data.MData.robotX = i
                        data.MData.robotY = j
                elif flags & cv2.EVENT_FLAG_RBUTTON:
                    if current_cell == 0:
                        current_cell = data.MData.checkpoint_counter
                        matrix[i][j] = current_cell  # Update the value in the matrix
                        data.MData.meetPunten.append((i, j))
                        updateGridImage(matrix, data)
                        print("meetPunten:", ",".join(f"{coord[0]}/{coord[1]}" for coord in data.MData.meetPunten))
            elif data.MData.mode == 2:
                if flags & cv2.EVENT_FLAG_LBUTTON:
                    if current_cell == 0:
                        current_cell = 6000
                        matrix[i][j] = current_cell  # Update the value in the matrix
                        updateGridImage(matrix, data)
                        data.MData.hoeken.append((i, j))
                        print("hoeken:", ",".join(f"{coord[0]}/{coord[1]}" for coord in data.MData.hoeken))
                elif flags & cv2.EVENT_FLAG_RBUTTON:
                    updateGridImage(matrix, data)
        elif event == cv2.EVENT_MOUSEWHEEL:
            data.MData.mode = (data.MData.mode + 1) % 3  # Cycle through modes 0, 1, and 2
            print(f"mode: {data.MData.mode}")

##!
# @brief Sets the data for image processing.
#
# This function sets the necessary data for processing image data. It calculates the longest dimension of the image and determines the cell size based on it. It creates an instance of the StoreData class and sets the begin and end coordinates. It extracts the region of interest (ROI) from the image and calculates the dimensions of the ROI image. It initializes a matrix with the appropriate dimensions and assigns it to the StoreData instance. Finally, it assigns other required parameters to the StoreData instance and returns the matrix and the StoreData instance.
#
# @param img The input image.
# @param begin The starting coordinates of the region of interest (ROI).
# @param end The ending coordinates of the region of interest (ROI).
# @param orig_img The original image.
# @return A tuple containing the matrix and an instance of the StoreData class.
#
def setData(img, begin, end, orig_img):
    longest_dim = max(img.shape[1], img.shape[0])
    cell_size = int(np.ceil(longest_dim / 300))

    uData = StoreData()
    uData.gData.beginX = begin[0]
    uData.gData.beginY = begin[1]

    roi = (begin[0], begin[1], end[0] - begin[0], end[1] - begin[1])
    roiImage = img[roi[1]:roi[1]+roi[3], roi[0]:roi[0]+roi[2]]

    width = int(np.ceil(roiImage.shape[1] / cell_size))
    height = int(np.ceil(roiImage.shape[0] / cell_size))

    matrix = [[0] * width for _ in range(height)]

    uData.MData.matrix = matrix
    uData.MData.cell_size = cell_size
    uData.MData.img = img
    uData.MData.orig_img = orig_img
    
    return matrix, uData

##!
# @brief Writes data to a text file.
#
# This function takes input data in the form of a `uData` object and a filename. It converts the tuples within the `uData` object to strings and combines them into a single string. The resulting string is then written to a text file specified by the filename.
#
# @param uData The input data object containing route, meetPunten, and hoeken attributes.
# @param filename The name of the text file to write the data to.
#
def writeToTxt(uData, filename):
    # Convert tuples to strings
    route_str = [f"{coord[0]}/{coord[1]}" for coord in uData.MData.route]
    meetPunten_str = [f"{coord[0]}/{coord[1]}" for coord in uData.MData.meetPunten]
    hoeken_str = [f"{coord[0]}/{coord[1]}" for coord in uData.MData.hoeken]

    # Combine the arrays into a single string
    data = ",".join(route_str) + "\n" + ",".join(meetPunten_str) + "\n" + ",".join(hoeken_str)
    
    with open(filename, "w") as file:
        file.write(data)

##!
# @brief Read the contents of a text file and split the data into separate arrays.
#
# This function reads the contents of a text file specified by the filename parameter. It then splits the data into three separate arrays and returns them.
#
# @param filename The name of the text file to read.
# @return Three arrays containing the data from the text file.
#
def readTxt(filename):
    # Read the contents of the text file
    with open(filename, "r") as file:
        data = file.read()

    # Split the data into separate arrays
    lines = data.split("\n")
    array1 = lines[0].split(",")
    array2 = lines[1].split(",")
    array3 = lines[2].split(",")
    
    return array1, array2, array3

##!
# @brief Creates a grid image with a centered and scaled version of the input image.
#
# This function takes an input image file and performs the following steps:
#   - Reads the image file and checks if it was successfully read.
#   - Calculates the aspect ratio of the original image.
#   - Scales the image to fit within the screen dimensions while maintaining the aspect ratio.
#   - Centers the scaled image on the screen.
#   - Creates a named window for the grid image.
#   - Sets a mouse callback function for the window to handle user interactions.
#   - Displays the grid image and waits for a key press.
#   - Writes data from the user interactions to a text file.
#   - Reads and prints arrays from the text file.
#
# @param filename The path to the input image file.
# @return The grid image matrix.
#
def createGridImage(filename):
    
    screen_Width = GetSystemMetrics(0)
    screen_Height = GetSystemMetrics(1)

    orig_img = cv2.imread(filename, cv2.IMREAD_COLOR)
    if orig_img is None:
        print("Could not read the image")

    image_Aspect_Ratio = orig_img.shape[1] / orig_img.shape[0]
    
    max_Width = screen_Width
    max_Height = screen_Height
 
    scaled_Width = max_Width
    scaled_Height = int(scaled_Width / image_Aspect_Ratio)

    if scaled_Height > max_Height:
        scaled_Height = max_Height
        scaled_Width = int(scaled_Height * image_Aspect_Ratio)

    pos_X = (screen_Width - scaled_Width) // 2
    pos_Y = (screen_Height - scaled_Height) // 2

    cv2.namedWindow("Grid Image")
    cv2.moveWindow("Grid Image", pos_X, pos_Y)
    orig_img = cv2.resize(orig_img, (scaled_Width, scaled_Height))
    
    img, begin, end = getRoi(orig_img)
    

    matrix, uData = setData(img, begin, end, orig_img)
    
    cv2.setMouseCallback("Grid Image", onMouse, uData)
    showInitialGrid(matrix, uData)

    cv2.waitKey(0)
    
    writeToTxt(uData, "arrays.txt")
    
    arr1, arr2, arr3 = readTxt("arrays.txt")
    print(arr1, "\n")
    print(arr2, "\n")
    print(arr3, "\n")

    
    arr1, arr2, arr3 = readTxt("arrays.txt")
    print(arr1, "\n")
    print(arr2, "\n")
    print(arr3, "\n")

    return matrix


def main():
    
    matrix = createGridImage("Finallayout.png")


if __name__ == '__main__':
    main()
