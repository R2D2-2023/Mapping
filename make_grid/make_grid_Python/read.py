import cv2
import numpy as np
from win32api import GetSystemMetrics

##
# @file read.py
# @brief functions for reading a array and for drawing on the grid 

##!
# @class MouseData
# @brief Represents mouse-related data and properties.
#
# This class encapsulates various attributes and data related to mouse behavior
# and processing. It provides properties for managing the mouse matrix, cell size,
# images, counters, route information, and other variables.
#
class MouseData:
    ##!
    # @brief Initializes a new instance of the MouseData class.
    #
    # This constructor initializes the MouseData object with default values for
    # the matrix, cell size, images, counters, route, and other variables.
    #
    def __init__(self):
        ## The mouse matrix.
        self.matrix = None
        ## The size of each cell in the matrix.
        self.cell_size = 0
        ## The current image.
        self.img = None
        ## The original image.
        self.origImg = None
        ## The counter value.
        self.counter = 0
        ## The checkpoint counter value.
        self.checkpoint_counter = -5
        ## the before position value
        self.before = None

##!
# @class GridData
# @brief Represents a grid data object.
#
# The GridData class manages grid-related data, including the beginning and ending coordinates.
#
class GridData:
    ##!
    # @brief Constructs a new GridData object.
    #
    # The constructor initializes the beginning and ending coordinates of the grid.
    #
    def __init__(self):
        ## The x-coordinate of the beginning of the grid.
        self.beginX = 0
        ## The y-coordinate of the beginning of the grid.
        self.beginY = 0
        ## The x-coordinate of the start of the grid.
        self.start = 0
        ## The y-coordinate of the end of the grid.
        self.end = 0

##!
# @class StoreData
# @brief Class for storing data.
#
# This class provides a mechanism for storing data using two different data types:
# - GridData: Represents grid-based data.
# - MouseData: Represents mouse-related data.
#

class StoreData :
    def __init__(self):
        self.G_Data = GridData()
        self.M_Data = MouseData()

##!
# @brief Updates the grid image based on the provided matrix data.
#
# This function takes a matrix and data object as input and updates the grid image.
# The grid image is generated by drawing rectangles on a copy of the original image
# using colors based on the values in the matrix.
#
# @param matrix The matrix containing the values.
# @param data The data object containing additional information.
#
def updateGridImage(matrix, data):
    grid_color = (0, 0, 255)
    grid_color_green = (0, 255, 0)
    grid_color_checkpoint = (255, 0, 255)
    grid_color_corner = (255, 255, 0)
    grid_img = data.M_Data.orig_Img.copy()
    cell_size = data.M_Data.cell_size

    for i in range(len(matrix)):
        y = data.G_Data.begin_Y + i * cell_size
        for j in range(len(matrix[i])):
            x = data.G_Data.begin_X + j * cell_size
            value = matrix[i][j]
            rect_color = None
            if value == 0:
                rect_color = grid_color
            elif value == 6000:
                rect_color = grid_color_corner
            elif value == 1000:
                rect_color = (255, 0, 0)
            else:
                if value < 0:
                    rect_color = grid_color_checkpoint
                else:
                    rect_color = grid_color_green
            cv2.rectangle(grid_img, (x, y), (x + cell_size, y + cell_size), rect_color, 1 if value == 0 else -1)
    
    cv2.imshow("Grid Image", grid_img)

##!
# @brief Read the contents of a text file and split the data into separate arrays.
#
# This function reads the contents of a text file specified by the filename parameter. It then splits the data into three separate arrays and returns them.
#
# @param filename The name of the text file to read.
# @return Three arrays containing the data from the text file.
#
def readTxt(filename):
    # Read the contents of the text file
    with open(filename, "r") as file:
        data = file.read()

    # Split the data into separate arrays
    lines = data.split("\n")
    array1 = lines[0].split(",")
    array2 = lines[1].split(",")
    array3 = lines[2].split(",")
    
    return array1, array2, array3

##!
# @brief Sets the data for image processing.
#
# This function sets the necessary data for processing image data. It calculates the longest dimension of the image and determines the cell size based on it. It creates an instance of the StoreData class and sets the begin and end coordinates. It extracts the region of interest (ROI) from the image and calculates the dimensions of the ROI image. It initializes a matrix with the appropriate dimensions and assigns it to the StoreData instance. Finally, it assigns other required parameters to the StoreData instance and returns the matrix and the StoreData instance.
#
# @param img The input image.
# @param begin The starting coordinates of the region of interest (ROI).
# @param end The ending coordinates of the region of interest (ROI).
# @param origImg The original image.
#
# @return A tuple containing the matrix and an instance of the StoreData class.
#
def setData(img, begin, end, orig_Img):
    longest_dim = max(img.shape[1], img.shape[0])
    cell_size = int(np.ceil(longest_dim / 300))

    u_Data = StoreData()
    u_Data.G_Data.begin_X = begin[0]
    u_Data.G_Data.begin_Y = begin[1]
    u_Data.G_Data.start = begin
    u_Data.G_Data.end = end
    

    roi = (begin[0], begin[1], end[0] - begin[0], end[1] - begin[1])
    roiImage = img[roi[1]:roi[1]+roi[3], roi[0]:roi[0]+roi[2]]

    width = int(np.ceil(roiImage.shape[1] / cell_size))
    height = int(np.ceil(roiImage.shape[0] / cell_size))

    matrix = [[0] * width for _ in range(height)]

    u_Data.M_Data.matrix = matrix
    u_Data.M_Data.cell_size = cell_size
    u_Data.M_Data.img = img
    u_Data.M_Data.orig_Img = orig_Img
    
    return matrix, u_Data

##!
# @brief Extracts the ROI from an image.
#
# This function takes an image as input and returns the ROI, start point, and end point of the grid.
#
# @param img The input image.
#
# @return A tuple containing the ROI image, start point, and end point.
#
def getRoi(img):
    hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # Define the lower and upper bounds of the black color range
    lower = np.array([0, 0, 0])
    upper = np.array([180, 255, 30])

    # Create a mask to filter out non-black pixels
    mask = cv2.inRange(hsv_img, lower, upper)
    
    # Apply the mask to the original image
    maskImg = cv2.bitwise_and(img, img, mask=mask)

    # Find the coordinates of black pixels
    coords = []
    for y in range(mask.shape[0]):
        for x in range(mask.shape[1]):
            if mask[y, x] == 255:
                coords.append((x, y))

    # Find the highest, lowest, leftmost, and rightmost points
    highestPoint = coords[0]
    lowestPoint = coords[0]
    leftmostPoint = coords[0]
    rightmostPoint = coords[0]

    for coord in coords:
        if coord[1] < highestPoint[1]:
            highestPoint = coord
        if coord[1] > lowestPoint[1]:
            lowestPoint = coord
        if coord[0] < leftmostPoint[0]:
            leftmostPoint = coord
        if coord[0] > rightmostPoint[0]:
            rightmostPoint = coord

    startPoint = (leftmostPoint[0], highestPoint[1])  # Starting coordinate of the grid
    endPoint = (rightmostPoint[0], lowestPoint[1])  # Ending coordinate of the grid
    
    return maskImg, startPoint, endPoint

##!
# @brief Convert pixel coordinates to grid cell coordinates, update the matrix, and return the grid cell coordinates.
#
# This function takes the pixel coordinates (pixel_x, pixel_y) and converts them to grid cell coordinates based on the data's cell size.
# It updates the matrix by setting the value of the previous grid cell to 0 (if it exists) and the value of the new grid cell to 1000.
# After updating the matrix, it calls `updateGridImage` to update the grid image using the updated matrix and data.
# Finally, it returns the grid cell coordinates.
#
# @param pixel_x (int): X-coordinate in pixels.
# @param pixel_y (int): Y-coordinate in pixels.
# @param data (object): Data containing information about the grid.
# @param matrix (list): 2D matrix.
#
# @return tuple: Grid cell coordinates as a tuple (row index, column index).
#
def makeGridCoords(pixel_x, pixel_y, data, matrix):
    if data.M_Data.before is not None:
        before = data.M_Data.before
        matrix[before[0]][before[1]] = 0
    
    # Use pixel coordinates as grid cell coordinates
    grid_cell_coordinates = (
        pixel_x // data.M_Data.cell_size,  # Column index
        pixel_y // data.M_Data.cell_size   # Row index
    )

    data.M_Data.before = grid_cell_coordinates
    
    matrix[grid_cell_coordinates[0]][grid_cell_coordinates[1]] = 1000
    updateGridImage(matrix, data)
    
    return grid_cell_coordinates

##!
# @brief Load arrays into a matrix and update the grid image.
#
# This function takes three arrays and a matrix and loads the cells from the arrays into the matrix.
# The cells from `arr1` are assigned incremental values starting from 1.
# The cells from `arr2` are assigned decremental values starting from -1.
# The cells from `arr3` are assigned a fixed value of 6000.
# After loading the cells, the function calls `updateGridImage` to update the grid image using the updated matrix and `u_Data`.
#
# @param arr1 (list): List of cells for array 1.
# @param arr2 (list): List of cells for array 2.
# @param arr3 (list): List of cells for array 3.
# @param matrix (list): 2D matrix.
# @param u_Data (object): Data for updating the grid image.
#
def loadArray(arr1, arr2, arr3, matrix, u_Data):
    c1 = 1
    c2 = -1
    
    for cell in arr1:
        x, y = map(int, cell.split("/"))
        matrix[x][y] = c1
        c1 += 1
        
    for cell in arr2:
        x, y = map(int, cell.split("/"))
        matrix[x][y] = c2
        c2 -= 1
        
    for cell in arr3:
        x, y = map(int, cell.split("/"))
        matrix[x][y] = 6000
    
    updateGridImage(matrix, u_Data)

##!
# @brief Creates a grid image with a centered and scaled version of the input image.
#
# This function takes an input image file and performs the following steps:
#   - Reads the image file and checks if it was successfully read.
#   - Calculates the aspect ratio of the original image.
#   - Scales the image to fit within the screen dimensions while maintaining the aspect ratio.
#   - Centers the scaled image on the screen.
#   - Creates a named window for the grid image.
#   - Sets a mouse callback function for the window to handle user interactions.
#   - Displays the grid image and waits for a key press.
#   - Writes data from the user interactions to a text file.
#   - Reads and prints arrays from the text file.
#
# @param filename The path to the input image file.
#
# @return The grid image matrix.
#
def createGridImage(filename):
    
    screenWidth = GetSystemMetrics(0)
    screenHeight = GetSystemMetrics(1)

    orig_Img = cv2.imread(filename, cv2.IMREAD_COLOR)
    if orig_Img is None:
        print("Could not read the image")

    imageAspectRatio = orig_Img.shape[1] / orig_Img.shape[0]
    
    maxWidth = screenWidth
    maxHeight = screenHeight
 
    scaledWidth = maxWidth
    scaledHeight = int(scaledWidth / imageAspectRatio)

    if scaledHeight > maxHeight:
        scaledHeight = maxHeight
        scaledWidth = int(scaledHeight * imageAspectRatio)

    posX = (screenWidth - scaledWidth) // 2
    posY = (screenHeight - scaledHeight) // 2

    cv2.namedWindow("Grid Image")
    cv2.moveWindow("Grid Image", posX, posY)
    orig_Img = cv2.resize(orig_Img, (scaledWidth, scaledHeight))
    
    
    img, begin, end = getRoi(orig_Img)

    matrix, u_Data = setData(img, begin, end, orig_Img)
    
    updateGridImage(matrix, u_Data)
    
    arr1, arr2, arr3 = readTxt("arrays.txt")
    loadArray(arr1, arr2, arr3, matrix, u_Data)
    
    grid_coordinates = makeGridCoords(450, 150, u_Data, matrix)
    print(grid_coordinates)
    
    cv2.waitKey(0)
    
    return matrix


def main():
    matrix = createGridImage("map_new_new_edited.png")

if __name__ == '__main__':
    main()
